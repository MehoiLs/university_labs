## Лабораторная работа 3: Алгоритмы с возвратом.

### Вариант 35-b
"Крестики-нолики. Дано поле NxN с исходной комбинацией крестиков и ноликов.
Необходимо проверить, что крестики (нолики) выигрывают всегда при любых ходах противоположной стороны

Выигрышем считается наличие на поле цепочки из M крестиков (ноликов)

Подсказка: пронумеруйте все пустые поля и перестановки покажут последовательность их
заполнения".

### Описание структуры программы

ds_sem4_lab3/**main.cpp** - точка запуска программы
ds_sem4_lab3/**TicTacToeWinPossibilityCalculator.h** - реализация задачи
ds_sem4_lab3/**TicTacToeField.h** - основные методы для работы с полем Крестиков-Ноликов

### Описание работы программы

Суть алгоритма:
1. Проверяем, правильно ли поле создано (если крестиков больше чем ноликов на 2, и наоборот)
   (можно выключить: см. `TicTacToeField::DISABLED_ASSERTION`)
2. Проверяем, завершилась ли игра (если да, то алгоритм завершается)
3. Собираем все пустые места на поле в вектор (и затем конвертируем в очередь)
4. Подсчитываем размер комбинаций на горизонтали, вертикали и диагоналях для конкретной позиции текущего игрока
   (если размер комбинации >= размеру "выигрышной цепочки", то считается, что данная позиция является выигрышной).
5. Аналогично подсчитываем размер комбинаций для противоположного игрока
6. Производим сравнения всех пустых позиций, выигрышных позиций игрока и выигрышных позиций противника и делаем выводы.
   *  По очереди вызываем рекурсивный метод для заполнения всех пустых позиций поля, передавая ему очередь с одним 
   элементом (Ранее мы собрали все пустые места в другую очередь. Мы берём по 1 элементу именно из этой очереди и передаём в метод).
   Таким образом, проверяем все возможные варианты заполнения поля, побывавав в каждом "первом" пустом месте.

**_ПРИМЕЧАНИЕ:_** Вообще, вышеупомянутый рекурсивный метод будет проверять абсолютно все кейсы, и бектрекинг 
в этом случае используется ТОЛЬКО при нахождении выигрышной позиции (тогда мы откатываемся на шаг назад).
Я решил это оставить для того, чтобы можно было проверить, что алгоритм в любом случае проверит абсолютно все кейсы.
Однако, в методе `TicTacToeWinPossibilityCalculator::performFillFieldUntilWinSpotIsFound` есть флаг
`foundLoseCase`, который и используется для обозначения того, что мы нашли позицию, при которой противоположная сторона
выигрывает. Если мы добавим дополнительную проверку в рекурсию:
`TicTacToeWinPossibilityCalculator::performFillFieldUntilWinSpotIsFound`
```cpp
if (emptySpots.empty() →   && foundLoseCase   ←) {
    return;
}
```
и также проверку в методе:
`TicTacToeWinPossibilityCalculator::calculateWinPossibility`
```cpp
while (!emptySpotsQueue.empty() →   && !foundLoseCase   ←) {
   auto cords = emptySpotsQueue.front();
   auto q = queue<Coordinates>();
   q.push(cords);
   performFillFieldUntilWinSpotIsFound(field, q, player, currentPlayer, winChainLength, foundLoseCase);
   emptySpotsQueue.pop();
}
```
то алгоритм будет работать быстрее, и будет сразу же останавливаться, если найдёт позицию, 
при которой противоположная сторона выигрывает, а не проверять всевозможные кейсы.
